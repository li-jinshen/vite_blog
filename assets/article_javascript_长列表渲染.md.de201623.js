import{_ as s,o as a,c as n,X as o}from"./chunks/framework.8aaf079c.js";const C=JSON.parse('{"title":"长列表渲染","description":"","frontmatter":{},"headers":[],"relativePath":"article/javascript/长列表渲染.md","filePath":"article/javascript/长列表渲染.md"}'),p={name:"article/javascript/长列表渲染.md"},l=o(`<h1 id="长列表渲染" tabindex="-1">长列表渲染 <a class="header-anchor" href="#长列表渲染" aria-label="Permalink to &quot;长列表渲染&quot;">​</a></h1><p><img src="https://picx.zhimg.com/70/v2-0f492fd4317ef9570de693387c61133e_1440w.avis?source=172ae18b&amp;biz_tag=Post" alt=""></p><h2 id="为什么需要虚拟列表" tabindex="-1">为什么需要虚拟列表 <a class="header-anchor" href="#为什么需要虚拟列表" aria-label="Permalink to &quot;为什么需要虚拟列表&quot;">​</a></h2><p>在正式&quot;吃席&quot;讨论虚拟列表前，我们先上个&quot;前菜&quot;看看什么是长列表。</p><p><a href="https://zhuanlan.zhihu.com/p/444778554" target="_blank" rel="noreferrer">原文章地址</a></p><h3 id="什么是长列表" tabindex="-1">什么是长列表 <a class="header-anchor" href="#什么是长列表" aria-label="Permalink to &quot;什么是长列表&quot;">​</a></h3><p>在前端的业务开发中，经常会碰到列表项，如果列表项数量过多，一般则会采用分页的方式来处理，而分页的形式也有2种：</p><ul><li>前后翻页</li><li>上下滚动</li></ul><p>前后翻页一般多用于后台管理系统中；而在用户端为保证较好用户体验，会采用上下无限滚动的方式，我们一般把这种列表叫做<strong>长列表</strong>。</p><p>比如，常见的微博列表等</p><p><img src="https://pic4.zhimg.com/v2-9e5d6518ef8ef038e2922c418b21f5c3_b.jpg" alt="动图封面"></p><h3 id="长列表的问题" tabindex="-1">长列表的问题 <a class="header-anchor" href="#长列表的问题" aria-label="Permalink to &quot;长列表的问题&quot;">​</a></h3><p>目前看来无限滚动的长列表对用户来说体验是很好的，但是这里会有个问题，当用户滚动的屏数过多时，就会出现页面滑动卡顿、数据渲染较慢、白屏的问题，究其原因是列表项过多，渲染了<strong>大量dom节点</strong>。</p><p>为了解决上述问题，就引入了一种叫<strong>虚拟列表</strong>的解决方案。</p><h3 id="虚拟列表的优势" tabindex="-1">虚拟列表的优势 <a class="header-anchor" href="#虚拟列表的优势" aria-label="Permalink to &quot;虚拟列表的优势&quot;">​</a></h3><p>下面就通过两组图示数据来对比下，当滚动大约10+页时引入了虚拟列表前后的区别：</p><p><strong>使用前</strong></p><ul><li><strong>FPS</strong>：10</li><li><strong>JS内存</strong>：121MB</li><li><strong>DOM节点数</strong>：46592</li></ul><p><img src="https://pic3.zhimg.com/v2-95e6ba8359ce77f0fc4b4eaebeb6e3aa_r.jpg" alt=""></p><p><strong>使用后</strong></p><ul><li><strong>FPS</strong>：40</li><li><strong>JS内存</strong>：102MB</li><li><strong>DOM节点数</strong>：24268</li></ul><p><img src="https://pic4.zhimg.com/v2-1d259e08f72b5fbe26b6f721e8a1d4cb_r.jpg" alt=""></p><p>可以看到在引入虚拟列表后，在<strong>FPS</strong>、<strong>JS内存</strong>、<strong>DOM节点数</strong>各方面上都有较大程度的提升，而且随着滚动页数的持续增加，其效果会更加显著。</p><h2 id="虚拟列表的原理" tabindex="-1">虚拟列表的原理 <a class="header-anchor" href="#虚拟列表的原理" aria-label="Permalink to &quot;虚拟列表的原理&quot;">​</a></h2><p>只对可见区域进行渲染，对非可见区域中的数据<strong>不渲染</strong>或<strong>部分渲染</strong>的技术，从而达到极高的渲染性能，虚拟列表其实是<strong>按需显示</strong>的一种实现。</p><p>如图示例，其组成一般包含3部分：</p><p>1. **可视区：**滚动容器元素的视觉可见区域。</p><p>2. **列表渲染区：**真实渲染列表元素的区域，<strong>列表渲染区大于等于可视区</strong>。</p><p>3. **真实列表区：**又叫可滚动区，滚动容器元素的内部内容区域。</p><p><img src="https://pic3.zhimg.com/v2-dd70616f382c51b7f85e5d5ce3dce8c6_r.jpg" alt=""></p><p>当用户操作滚动列表后：</p><p>1. 显示可视区中的元素（item3~item12）</p><p>2. 隐藏可视区外中的元素（item3和item12之外的）</p><p><img src="https://pic2.zhimg.com/v2-21145cc94fd8d2064a1d15e489dc22f1_r.jpg" alt=""></p><h2 id="虚拟列表的实现" tabindex="-1">虚拟列表的实现 <a class="header-anchor" href="#虚拟列表的实现" aria-label="Permalink to &quot;虚拟列表的实现&quot;">​</a></h2><p>&quot;君子动手不动口&quot;，说了这么多，下面我们就来实操下具体如何实现一个虚拟列表，本文是以React为例。</p><h3 id="视图结构" tabindex="-1">视图结构 <a class="header-anchor" href="#视图结构" aria-label="Permalink to &quot;视图结构&quot;">​</a></h3><p>按照图示，我们先构造如下的视图结构</p><p>1. **viewport：**可视区域的容器</p><ol start="2"><li>**list-phantom：**容器内的占位，高度为真实列表区域的高度，用于形成滚动条</li></ol><p>3. **list-area：**列表项的渲染区域</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">viewport</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">list-phantom</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">list-area</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#676E95;font-style:italic;">&lt;!-- item-1 --&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#676E95;font-style:italic;">&lt;!-- item-2 --&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#676E95;font-style:italic;">&lt;!-- item-n --&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><h3 id="基本思路" tabindex="-1">基本思路 <a class="header-anchor" href="#基本思路" aria-label="Permalink to &quot;基本思路&quot;">​</a></h3><p>从虚拟列表的原理中可以知道，其核心思路是处理用户滚动时可视区元素的显示和可视区外元素的隐藏，这里为了方便说明，引入以下相关变量：</p><p>1. <strong>startIndex</strong>：可视区第一个元素标号（图示中为3）</p><p>2. <strong>endIndex</strong>：可视区最后一个元素标号（图示中为12）</p><p>3. <strong>startOffset</strong>：可视区第一个元素的向上偏移量</p><p>当用户滚动列表时：</p><p>1. 计算可视区的 <strong>startIndex</strong> 和 <strong>endIndex</strong></p><p>2. 根据 <strong>startIndex</strong> 和 <strong>endIndex</strong> 渲染数据</p><p>3. 计算 <strong>startOffset</strong> 偏移量并设置到列表渲染区</p><p><img src="https://pic1.zhimg.com/v2-a44b407830368cd10ae956d582847294_r.jpg" alt=""></p><h3 id="事件处理" tabindex="-1">事件处理 <a class="header-anchor" href="#事件处理" aria-label="Permalink to &quot;事件处理&quot;">​</a></h3><p>这里我们先假定列表项的<strong>高度固定</strong>为100px，则我们可设置和推导出：</p><p>1. 列表项高度 <code>itemSize = 100</code></p><p>2. 可视区可显示数量 <code>viewcount = viewport / itemSize</code></p><p>3. 可视区最后一个元素标号 <code>endIndex = startIndex + viewcount</code></p><p>当用户滚动时，逻辑处理如下：</p><p>1. 获取可视区滚动距离 <code>scrollTop</code>;</p><p><strong>2. 根据 scrollTop 和 itemSize 计算出 startIndex 和 endIndex;</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 获取startIndex </span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> getStartIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">scrollTop</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Math</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">floor</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">scrollTop</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">/</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">itemSize</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 这里可以思考下，为什么要用Math.floor </span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><p>3. 根据 <code>startIndex</code> 和 <code>itemSize</code> 计算出 <code>startOffset</code>;</p><p>4. 只显示<code>startIndex</code> 和 <code>endIndex</code>之间的元素;</p><p>5. 设置 <code>list-area</code> 的偏移量为 <code>startOffset</code>;</p><p>其中第2步是比较关键的（后面也会多次提到），其实计算出了<strong>startIndex 也就计算出了endIndex 和 startOffset；</strong></p><h3 id="实现效果" tabindex="-1">实现效果 <a class="header-anchor" href="#实现效果" aria-label="Permalink to &quot;实现效果&quot;">​</a></h3><p>最终的效果如下，具体代码实现可查看<a href="https://codesandbox.io/s/virtuallist1-etwdo?file=/src/App.jsx" target="_blank" rel="noreferrer">在线示例。</a></p><p><img src="https://pic1.zhimg.com/v2-1a57c6737c26efc2859ce782adb26404_b.jpg" alt="动图封面"></p><h2 id="动态高度" tabindex="-1">动态高度 <a class="header-anchor" href="#动态高度" aria-label="Permalink to &quot;动态高度&quot;">​</a></h2><p>&quot;理想很丰满，现实很骨感&quot;，实际上在业务开发中，基本很少碰到高度项列表固定的情况，大部分是文本、图片、富文本等不定的高度，对于这类不定的高度那我们该如何处理呢？</p><h3 id="动态高度的类型" tabindex="-1">动态高度的类型 <a class="header-anchor" href="#动态高度的类型" aria-label="Permalink to &quot;动态高度的类型&quot;">​</a></h3><p>对于这类不定的高度，我们一般可以分为两种类型：</p><p>1. 逻辑动态高度</p><p>2. 动态高度（由渲染内容决定高度）比如，文本、图片、富文本。</p><p>以上两种类型都可以在内容渲染完成后，获得其高度；但是不同的是 <strong>逻辑动态高度</strong> 也可以在渲染前通过业务数据计算得出，本质上也可以理解为固定高度，只是获取方式复杂了些；而类型2中的只能在<strong>内容渲染完成后</strong>才可以获取。以下动态高度的讨论都是指类型2。</p><h3 id="事件通知" tabindex="-1">事件通知 <a class="header-anchor" href="#事件通知" aria-label="Permalink to &quot;事件通知&quot;">​</a></h3><p>这里我们也比较容易想到，当渲染完成后，我们获取到列表项的高度信息，然后再更新指定列表项的高度。</p><p><img src="https://pic4.zhimg.com/v2-a78e25d5f2d1012f1631fa0b5f434f9f_r.jpg" alt=""></p><p><strong>具体实现</strong></p><p>构造记录列表项位置信息 <strong>position</strong> 的数组 <strong>positions</strong>：</p><p>1. <strong>top:</strong> 当前项顶部到列表顶部的距离</p><p>2. <strong>height:</strong> 当前项的高度</p><p>3. <strong>bottom:</strong> 当前项底部到列表顶部的距离</p><p>4. <strong>index:</strong> 当前项的标识</p><p>那么计算<strong>startIndex</strong>的逻辑则变为：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 获取startIndex </span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> getStartIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">scrollTop</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">item</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">positions</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">find</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">i</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bottom</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">scrollTop</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><p>当有item项高度变化后，我们只需要维护这一份 <strong>positions</strong> 数据即可，从而大大减少了处理起来的复杂度。</p><p><img src="https://pic4.zhimg.com/v2-840acfa80f562ed18271f51c7983a68b_r.jpg" alt=""></p><p>那么我们以 <code>item-3</code> 项为例，来具体看下当其高度变化后的具体影响</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 高度变化前position信息</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#F07178;">      </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">index</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 当前列表项的标识      </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">height</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">defaultItemSize</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 当前列表项高度（默认初始高度）      </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">top</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">index</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">defaultItemSize</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 当前项顶部到列表顶部的距离       </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">bottom</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">index</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">defaultItemSize</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//当前项底部到列表顶部的距离 </span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 高度变化后，设变化的高度dHeight = newHeight - oldHeight </span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#F07178;">      </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">index</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 当前列表项的标识      </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">height</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">defaultItemSize</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">dHeight</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 当前列表项高度      </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">top</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">index</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">defaultItemSize</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//当前项顶部到列表顶部的距离       </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">bottom</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">index</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">defaultItemSize</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">dHeight</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//当前项底部到列表顶部的距离 </span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>可以看到当<code>item-3</code>变化后，只有<code>height</code>和<code>bottom</code>发送了变化，<code>top</code>并未发生变化，不过这里需要注意，还需要更新<code>item-4~n</code>的信息，即<strong>向下更新</strong>相关项的位置信息。</p><p>具体代码实现，可查看<a href="https://codesandbox.io/s/virtuallist2-70ii1?file=/src/App.jsx" target="_blank" rel="noreferrer">在线示例</a>。</p><h3 id="主动监听" tabindex="-1">主动监听 <a class="header-anchor" href="#主动监听" aria-label="Permalink to &quot;主动监听&quot;">​</a></h3><p>那事件绑定会有什么问题呢？</p><p>当业务足够复杂时，会有大量操作触发高度更新，会导致有大量的绑定事件，从而对性能造成影响；也有可能遗漏绑定相关的事件，导致高度不更新，影响用户体验。</p><p>所以看来，事件通知的方式不管是对性能还是用户体验都是不太理想的。下面介绍另一种实现方式。</p><p><strong>ResizeObserver API</strong></p><p>我们先看看MDN的介绍</p><p><img src="https://pic1.zhimg.com/v2-f998e02b49316e498d0af76f44590a9c_r.jpg" alt=""></p><p>简单来说，<code>ResizeObserver</code>可以监听到指定元素的高度的变化，而且是原生浏览器层面的支持，性能方面也是可靠的。</p><p>兼容性方面，除了IE，其他也都是支持的：</p><p><img src="https://pic2.zhimg.com/v2-44bb93c82f4776bc1414ac725fe70bc9_r.jpg" alt=""></p><p>关键代码实现：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 监听高度变化</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> observe </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">resizeObserver</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">ResizeObserver</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 获取当前列表项的高度</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">el</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">element</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">current</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">el</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">offsetHeight</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 触发高度更新</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">measure</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">offsetHeight</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">resizeObserver</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">observe</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">element</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">current</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">resizeObserver</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">disconnect</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span></code></pre></div><h3 id="实现效果-1" tabindex="-1">实现效果 <a class="header-anchor" href="#实现效果-1" aria-label="Permalink to &quot;实现效果&quot;">​</a></h3><p>最终采用主动监听的效果如下，具体代码实现可查看<a href="https://codesandbox.io/s/virtuallist3-irpi3" target="_blank" rel="noreferrer">在线示例。</a></p><p><img src="https://pic2.zhimg.com/v2-34dd736d3c475002e0ba5b5331daf0c1_b.jpg" alt="动图封面"></p><h2 id="探索优化" tabindex="-1">探索优化 <a class="header-anchor" href="#探索优化" aria-label="Permalink to &quot;探索优化&quot;">​</a></h2><p>到此为止，我们就实现了一个<strong>支持动态高度</strong>虚拟列表，那是不是到这里就结束了呢，当然不是，在技术的研究上，我们要像我国的航天事业一样&quot;弘扬探月精神，勇攀科技高峰&quot;，勇于探索，勇于创新。</p><p>这里的话，笔者总结出了下面2个问题，当然也不止这2个问题，大家也可以自己思考下。</p><p>1. 滚动过快出现会白屏</p><p>2. 滚动时有大量的计算</p><h3 id="白屏优化" tabindex="-1">白屏优化 <a class="header-anchor" href="#白屏优化" aria-label="Permalink to &quot;白屏优化&quot;">​</a></h3><p><strong>方案一：增加缓存区</strong></p><p>在虚拟列表的原理中有提到过，**列表渲染区是可以大于等于可视区，**这里的采取措施就是列表渲染区域要大于可视区。</p><p>**措施：**在可视区外设置缓存区，额外渲染合适的列表项。</p><p>**优势：**在滚动过快时，会先显示缓存区中的元素，减少白屏出现的情况。</p><p>**不足：**缓存区域设置过大，也会导致渲染性能变差，需要结合具体的业务场景设置合适的缓存值。</p><p><img src="https://pic2.zhimg.com/v2-455ef80f7de862d5bf517a3f3c05ae8d_r.jpg" alt=""></p><p><strong>方案二：部分渲染</strong></p><p>在前面虚拟列表的原理中也有提到过，对非可见区域中的数据<strong>不渲染</strong>或<strong>部分渲染</strong>的技术，这里所用到的就是不可见列表项的部分渲染。</p><p>**措施：**采用<code>skeleton</code>加载骨架屏来代替原有的不渲染部分，这样当滚动过快时，白屏也就替换为了加载屏。</p><p>**优势：**用户体验上会有所增强。</p><p>**不足：**会额外渲染<code>skeleton</code>的<code>dom</code>元素。不过对比整个列表元素的<code>dom</code>节点来看，可以忽略不计的。</p><p><img src="https://pic4.zhimg.com/v2-9d8c1abbdb54d5c5ff0f8c5682a0c503_r.jpg" alt=""></p><h3 id="计算优化" tabindex="-1">计算优化 <a class="header-anchor" href="#计算优化" aria-label="Permalink to &quot;计算优化&quot;">​</a></h3><p>首页我们来看下，上一节提到的 <code>positions</code> 数组其实是个标准的按照各项位置升序的<strong>有序数组</strong>。</p><p>而最重要的和调用次数最多的逻辑是计算<strong>startIndex：</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 获取startIndex </span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> getStartIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">scrollTop</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">item</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">positions</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">find</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">i</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bottom</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">scrollTop</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><p>所有，我们可以采用二分查找法来进行优化，具体二分查找法的实现就不在这里展开了，可查看在线示例。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> getStartIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">scrollTop</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#89DDFF;">   </span><span style="color:#676E95;font-style:italic;">// let item = positions.find((i) =&gt; i &amp;&amp; i.bottom &gt; scrollTop); </span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">item</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">binarySearch</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">positions</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">scrollTop</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><p>其时间复杂度也从<code>O(n)</code> 降为 <code>O(logn)</code>；</p><h3 id="实现效果-2" tabindex="-1">实现效果 <a class="header-anchor" href="#实现效果-2" aria-label="Permalink to &quot;实现效果&quot;">​</a></h3><p>最终优化过的效果如下，具体代码实现可查看<a href="https://codesandbox.io/s/virtuallis4-tyoo9?file=/src/App.jsx" target="_blank" rel="noreferrer">在线示例。</a></p><p><img src="https://pic4.zhimg.com/v2-0995c62c245d7ce8e5925bdf3ef0b2c7_b.jpg" alt="动图封面"></p><h2 id="面向未来" tabindex="-1">面向未来 <a class="header-anchor" href="#面向未来" aria-label="Permalink to &quot;面向未来&quot;">​</a></h2><h3 id="多平台支持" tabindex="-1">多平台支持 <a class="header-anchor" href="#多平台支持" aria-label="Permalink to &quot;多平台支持&quot;">​</a></h3><p>下面是虚拟列表的通用模型 ，而对于其他平台如<code>小程序</code>、<code>IOS</code>、<code>flutter</code>等的实现，或者能不能抽象出一套通用架构，对于不同的平台只需在这套架构上实现特定平台的代码逻辑即可产出特定平台的虚拟列表，也是未来需要进一步探索研究的。</p><p><img src="https://pic3.zhimg.com/v2-49ee5f4f10b5aa9f2f7974166d686e56_r.jpg" alt=""></p>`,139),t=[l];function e(r,c,i,y,F,D){return a(),n("div",null,t)}const A=s(p,[["render",e]]);export{C as __pageData,A as default};
